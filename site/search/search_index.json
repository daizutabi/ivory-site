{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ivory Overview Ivory is a lightweight machine learning framework. Installation You can install Ivory from PyPI. $ pip install ivory","title":"Ivory"},{"location":"#ivory","text":"","title":"Ivory"},{"location":"#overview","text":"Ivory is a lightweight machine learning framework.","title":"Overview"},{"location":"#installation","text":"You can install Ivory from PyPI. $ pip install ivory","title":"Installation"},{"location":"tutorial/data/","text":"Data Create data As a simple toy example, we try to predict area of rectangles which have width and height , but they include some noises. First, define a function to create such data. import numpy as np import pandas as pd import ivory from ivory.utils import kfold_split def create_data(num_samples=1000): \"\"\"Returns a tuple of (input, target). Target has fold information.\"\"\" x = 4 * np.random.rand(num_samples, 2) + 1 x = x.astype(np.float32) noises = 0.1 * (np.random.rand(2, num_samples) - 0.5) df = pd.DataFrame(x, columns=[\"width\", \"height\"]) df[\"area\"] = (df.width + noises[0]) * (df.height + noises[1]) df.area = df.area.astype(np.float32) df[\"fold\"] = kfold_split(df.index, n_splits=5) return df[[\"width\", \"height\"]], df[[\"fold\", \"area\"]] [1] 2020-03-12 01:59:09 ( 6.00ms ) python3 ( 1.81s ) kfold_split function creates a fold-array. kfold_split(np.arange(10), n_splits=3) [2] 2020-03-12 01:59:09 ( 5.00ms ) python3 ( 1.82s ) array([2, 1, 0, 2, 0, 2, 1, 1, 0, 0], dtype=int8) To execute create_data funtion, you can use a dictionary as well as a YAML file. params = {'data': {'def': 'create_data'}} [3] 2020-03-12 01:59:09 ( 3.01ms ) python3 ( 1.82s ) The key of def means that the value is a funtion instead of a class. Apply this dictionary to ivory.instantiate function to get an instantiated object dictionary. data = ivory.instantiate(params)['data'] data[0].head() [4] 2020-03-12 01:59:09 ( 9.00ms ) python3 ( 1.83s ) width height 0 2.721977 2.108382 1 3.904444 2.768574 2 1.438495 4.878826 3 3.680521 2.841346 4 3.493506 4.525074 data[1].head() [5] 2020-03-12 01:59:09 ( 5.00ms ) python3 ( 1.84s ) fold area 0 2 5.675824 1 0 10.749290 2 1 7.138609 3 2 10.390873 4 3 15.907549 You can change the data size with additional key-value pairs (in this case, the minimun size is the number of fold 5). params = {'data': {'def': 'create_data', 'num_samples': 5}} ivory.instantiate(params)['data'][1] [6] 2020-03-12 01:59:09 ( 8.00ms ) python3 ( 1.84s ) fold area 0 1 3.548383 1 2 6.152096 2 0 5.675569 3 3 21.535194 4 4 5.301344 Dataset Ivory provides ivory.torch.Dataset for PyTorch. from ivory.torch import Dataset dataset = Dataset(data[0], data[1]) dataset [7] 2020-03-12 01:59:09 ( 5.00ms ) python3 ( 1.85s ) Dataset(num_samples=1000, input_shape=(2,), target_shape=(2,), mode='train') Ivory's Dataset is a subclass of PyTorch's Dataset import torch.utils.data isinstance(dataset, torch.utils.data.Dataset) [8] 2020-03-12 01:59:09 ( 4.00ms ) python3 ( 1.85s ) True Check an item. dataset[0] [9] 2020-03-12 01:59:09 ( 4.00ms ) python3 ( 1.86s ) (0, array([2.7219775, 2.1083822], dtype=float32), array([2. , 5.6758237], dtype=float32)) Indexing returns a tuple. The first is an index, the second is an input, and the last is a target. The target includes fold which is not a real target. But, it's okay because we don't use a Dataset directly. We can use more usefull DataLoaders provided by Ivory. DataLoaders DataLoaders provides a data loader for both training and validation. This is the reason why our data include fold information. from ivory.torch import DataLoaders dataloaders = DataLoaders(data[0], data[1], batch_size=3) dataloaders [10] 2020-03-12 01:59:09 ( 4.00ms ) python3 ( 1.86s ) DataLoaders(num_folds=5, num_samples=1000, input_shape=(2,), target_shape=(1,)) DataLoaders instance can detect the number of fold and remove the fold information from the target. Normal indexing can be used to get a pair of train data loader and validation data loader. train_loader, val_loader = dataloaders[0] [11] 2020-03-12 01:59:09 ( 4.00ms ) python3 ( 1.87s ) Here, index means fold number, in this case, ranging from 0 to 4 because the number of K-fold is 5. Check the data loarder. train_loader [12] 2020-03-12 01:59:09 ( 3.00ms ) python3 ( 1.87s ) <torch.utils.data.dataloader.DataLoader at 0x249f06937c8> The data loader is a pure PyTorch's DataLoader . Let's see the dataset that the data loader has. train_loader.dataset [13] 2020-03-12 01:59:09 ( 3.00ms ) python3 ( 1.87s ) Dataset(num_samples=800, input_shape=(2,), target_shape=(1,), mode='train') This is our Ivory's dataset. The number of samples reduces from 1000 to 800 because we uses 5 folds (80% reduction). Validation dataset shoud have the rest 20% samples. val_loader.dataset [14] 2020-03-12 01:59:09 ( 4.00ms ) python3 ( 1.88s ) Dataset(num_samples=200, input_shape=(2,), target_shape=(1,), mode='val') Now check iteration. it = iter(train_loader) next(it) [15] 2020-03-12 01:59:09 ( 8.00ms ) python3 ( 1.88s ) [tensor([ 84, 393, 338]), tensor([[3.2827, 1.2530], [2.2827, 2.7727], [4.4101, 3.5365]]), tensor([[ 4.1268], [ 6.4488], [15.4162]])] next() returns a list of torch.Tensor . The first is an index, the second is an input, and the last is a target. Note that the target doesn't include fold any more. In default setting, train data loader shuffles its data. Validation data loader doesn't: it = iter(val_loader) next(it) [16] 2020-03-12 01:59:09 ( 4.00ms ) python3 ( 1.89s ) [tensor([1, 5, 8]), tensor([[3.9044, 2.7686], [3.0229, 4.9662], [3.1588, 2.9484]]), tensor([[10.7493], [14.9745], [ 9.4358]])] DataLoaders","title":"Data"},{"location":"tutorial/data/#data","text":"","title":"Data"},{"location":"tutorial/data/#create-data","text":"As a simple toy example, we try to predict area of rectangles which have width and height , but they include some noises. First, define a function to create such data. import numpy as np import pandas as pd import ivory from ivory.utils import kfold_split def create_data(num_samples=1000): \"\"\"Returns a tuple of (input, target). Target has fold information.\"\"\" x = 4 * np.random.rand(num_samples, 2) + 1 x = x.astype(np.float32) noises = 0.1 * (np.random.rand(2, num_samples) - 0.5) df = pd.DataFrame(x, columns=[\"width\", \"height\"]) df[\"area\"] = (df.width + noises[0]) * (df.height + noises[1]) df.area = df.area.astype(np.float32) df[\"fold\"] = kfold_split(df.index, n_splits=5) return df[[\"width\", \"height\"]], df[[\"fold\", \"area\"]] [1] 2020-03-12 01:59:09 ( 6.00ms ) python3 ( 1.81s ) kfold_split function creates a fold-array. kfold_split(np.arange(10), n_splits=3) [2] 2020-03-12 01:59:09 ( 5.00ms ) python3 ( 1.82s ) array([2, 1, 0, 2, 0, 2, 1, 1, 0, 0], dtype=int8) To execute create_data funtion, you can use a dictionary as well as a YAML file. params = {'data': {'def': 'create_data'}} [3] 2020-03-12 01:59:09 ( 3.01ms ) python3 ( 1.82s ) The key of def means that the value is a funtion instead of a class. Apply this dictionary to ivory.instantiate function to get an instantiated object dictionary. data = ivory.instantiate(params)['data'] data[0].head() [4] 2020-03-12 01:59:09 ( 9.00ms ) python3 ( 1.83s ) width height 0 2.721977 2.108382 1 3.904444 2.768574 2 1.438495 4.878826 3 3.680521 2.841346 4 3.493506 4.525074 data[1].head() [5] 2020-03-12 01:59:09 ( 5.00ms ) python3 ( 1.84s ) fold area 0 2 5.675824 1 0 10.749290 2 1 7.138609 3 2 10.390873 4 3 15.907549 You can change the data size with additional key-value pairs (in this case, the minimun size is the number of fold 5). params = {'data': {'def': 'create_data', 'num_samples': 5}} ivory.instantiate(params)['data'][1] [6] 2020-03-12 01:59:09 ( 8.00ms ) python3 ( 1.84s ) fold area 0 1 3.548383 1 2 6.152096 2 0 5.675569 3 3 21.535194 4 4 5.301344","title":"Create data"},{"location":"tutorial/data/#dataset","text":"Ivory provides ivory.torch.Dataset for PyTorch. from ivory.torch import Dataset dataset = Dataset(data[0], data[1]) dataset [7] 2020-03-12 01:59:09 ( 5.00ms ) python3 ( 1.85s ) Dataset(num_samples=1000, input_shape=(2,), target_shape=(2,), mode='train') Ivory's Dataset is a subclass of PyTorch's Dataset import torch.utils.data isinstance(dataset, torch.utils.data.Dataset) [8] 2020-03-12 01:59:09 ( 4.00ms ) python3 ( 1.85s ) True Check an item. dataset[0] [9] 2020-03-12 01:59:09 ( 4.00ms ) python3 ( 1.86s ) (0, array([2.7219775, 2.1083822], dtype=float32), array([2. , 5.6758237], dtype=float32)) Indexing returns a tuple. The first is an index, the second is an input, and the last is a target. The target includes fold which is not a real target. But, it's okay because we don't use a Dataset directly. We can use more usefull DataLoaders provided by Ivory.","title":"Dataset"},{"location":"tutorial/data/#dataloaders","text":"DataLoaders provides a data loader for both training and validation. This is the reason why our data include fold information. from ivory.torch import DataLoaders dataloaders = DataLoaders(data[0], data[1], batch_size=3) dataloaders [10] 2020-03-12 01:59:09 ( 4.00ms ) python3 ( 1.86s ) DataLoaders(num_folds=5, num_samples=1000, input_shape=(2,), target_shape=(1,)) DataLoaders instance can detect the number of fold and remove the fold information from the target. Normal indexing can be used to get a pair of train data loader and validation data loader. train_loader, val_loader = dataloaders[0] [11] 2020-03-12 01:59:09 ( 4.00ms ) python3 ( 1.87s ) Here, index means fold number, in this case, ranging from 0 to 4 because the number of K-fold is 5. Check the data loarder. train_loader [12] 2020-03-12 01:59:09 ( 3.00ms ) python3 ( 1.87s ) <torch.utils.data.dataloader.DataLoader at 0x249f06937c8> The data loader is a pure PyTorch's DataLoader . Let's see the dataset that the data loader has. train_loader.dataset [13] 2020-03-12 01:59:09 ( 3.00ms ) python3 ( 1.87s ) Dataset(num_samples=800, input_shape=(2,), target_shape=(1,), mode='train') This is our Ivory's dataset. The number of samples reduces from 1000 to 800 because we uses 5 folds (80% reduction). Validation dataset shoud have the rest 20% samples. val_loader.dataset [14] 2020-03-12 01:59:09 ( 4.00ms ) python3 ( 1.88s ) Dataset(num_samples=200, input_shape=(2,), target_shape=(1,), mode='val') Now check iteration. it = iter(train_loader) next(it) [15] 2020-03-12 01:59:09 ( 8.00ms ) python3 ( 1.88s ) [tensor([ 84, 393, 338]), tensor([[3.2827, 1.2530], [2.2827, 2.7727], [4.4101, 3.5365]]), tensor([[ 4.1268], [ 6.4488], [15.4162]])] next() returns a list of torch.Tensor . The first is an index, the second is an input, and the last is a target. Note that the target doesn't include fold any more. In default setting, train data loader shuffles its data. Validation data loader doesn't: it = iter(val_loader) next(it) [16] 2020-03-12 01:59:09 ( 4.00ms ) python3 ( 1.89s ) [tensor([1, 5, 8]), tensor([[3.9044, 2.7686], [3.0229, 4.9662], [3.1588, 2.9484]]), tensor([[10.7493], [14.9745], [ 9.4358]])]","title":"DataLoaders"},{"location":"tutorial/data/#dataloaders_1","text":"","title":"DataLoaders"},{"location":"tutorial/experiment/","text":"Experiment The first start point in Ivory is ivory.Experiment . This master object controls a machine learning experiment under a certain condition. Let's create your first Experiment instance. In your favorite directory, write a YAML file like below named params_0.yaml : File params_0.yaml experiment: class: ivory.Experiment The class key notices that the experiment is an instance of ivory.Experiment . Then, in a jupyte notebook or a Python script under the same directory. import ivory experiment = ivory.create_experiment('params_0.yaml') experiment [1] 2020-03-12 00:15:04 ( 1.48s ) python3 ( 1.48s ) Experiment(name='ready', run_class='ivory.core.Run', shared=[], num_runs=0) You created an Experiment instance. It says that its name is \"ready\" and its run_class is ivory.core.Run . Next, you can start the Experiment . experiment.start() experiment [2] 2020-03-12 00:15:05 ( 6.00ms ) python3 ( 1.49s ) Experiment(name='2020/03/12 00:15:05', run_class='ivory.core.Run', shared=[], num_runs=0) The name is changed to the current time. Experiment is like an environment. Actual interesting processes such as machine learning are done by Run s. So, create a Run . run = experiment.create_run() run [3] 2020-03-12 00:15:05 ( 5.01ms ) python3 ( 1.49s ) Run(name='#1', callbacks=[]) This Run instance was named '#1' because this is the first one for the Experiment . Do you want to start a run? Let's try it. run.start() [4] 2020-03-12 00:15:05 ( 105ms ) python3 ( 1.60s ) AttributeError: 'Run' object has no attribute 'trainer' AttributeError Traceback (most recent call last) <ipython-input-7-c930d12f52e8> in <module> ----> 1 run.start() ~\\Documents\\GitHub\\ivory\\ivory\\core\\run.py in start(self) 37 self.on_fit_start() 38 try: ---> 39 self.trainer.fit(self) 40 finally: 41 self.on_fit_end() Oops! The Run instance has the method indeed, but it says there is no trainer . Of course, we need data, model, metrics, etc . for machine learning. Also, we need to decide how to train the model. Following sections will explain this process step by step.","title":"Experiment"},{"location":"tutorial/experiment/#experiment","text":"The first start point in Ivory is ivory.Experiment . This master object controls a machine learning experiment under a certain condition. Let's create your first Experiment instance. In your favorite directory, write a YAML file like below named params_0.yaml : File params_0.yaml experiment: class: ivory.Experiment The class key notices that the experiment is an instance of ivory.Experiment . Then, in a jupyte notebook or a Python script under the same directory. import ivory experiment = ivory.create_experiment('params_0.yaml') experiment [1] 2020-03-12 00:15:04 ( 1.48s ) python3 ( 1.48s ) Experiment(name='ready', run_class='ivory.core.Run', shared=[], num_runs=0) You created an Experiment instance. It says that its name is \"ready\" and its run_class is ivory.core.Run . Next, you can start the Experiment . experiment.start() experiment [2] 2020-03-12 00:15:05 ( 6.00ms ) python3 ( 1.49s ) Experiment(name='2020/03/12 00:15:05', run_class='ivory.core.Run', shared=[], num_runs=0) The name is changed to the current time. Experiment is like an environment. Actual interesting processes such as machine learning are done by Run s. So, create a Run . run = experiment.create_run() run [3] 2020-03-12 00:15:05 ( 5.01ms ) python3 ( 1.49s ) Run(name='#1', callbacks=[]) This Run instance was named '#1' because this is the first one for the Experiment . Do you want to start a run? Let's try it. run.start() [4] 2020-03-12 00:15:05 ( 105ms ) python3 ( 1.60s ) AttributeError: 'Run' object has no attribute 'trainer' AttributeError Traceback (most recent call last) <ipython-input-7-c930d12f52e8> in <module> ----> 1 run.start() ~\\Documents\\GitHub\\ivory\\ivory\\core\\run.py in start(self) 37 self.on_fit_start() 38 try: ---> 39 self.trainer.fit(self) 40 finally: 41 self.on_fit_end() Oops! The Run instance has the method indeed, but it says there is no trainer . Of course, we need data, model, metrics, etc . for machine learning. Also, we need to decide how to train the model. Following sections will explain this process step by step.","title":"Experiment"}]}